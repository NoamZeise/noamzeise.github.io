<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>3D Skeletal Animation With Vulkan | NoamZeise</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="3D Skeletal Animation With Vulkan" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I’ve added Skeletal animation to my Vulkan game framwork. I already use assimp to load in 3D models, but the library also loads animations if the model has them. I’ve revamped the model loading system to be able to load animated and non-animated models auutomically, and the renderer can take a model and an animation and render the current state of the animation to the screen. Vulkan Framwork Source Code Model I used: Wolf by 3D Haupt How it works The Animation is stored as a hierarchy of bones, where each bone has a number of keyframes for scale, position and rotation, and a parent bone. Each bone corresponds to a 4×4 transform matrix that transforms the verticies from local to bone space. These transform matricies are calculated each frame and applied in the shader. In my implementation I send a uniform that holds and array of bone transform matricies that can be accessed by the animated verticies. const int MAX_BONES = 50; layout(set = 2, binding = 0) uniform boneView { mat4 mat[MAX_BONES]; } bones; As the animation plays, the current frame’s bone matricies are calculated using the keyframes of each bone. When an animation timing lands between two keyframes, the state is linearly interpreted using the two surrounding frames and the time the animation is at. Furthermore each matrix is multiplied by it’s parent’s matrix so that, say, a hand will move if an arm moves, without having to specifically move the hand too. Each vertex on the model has a number of bone IDs and weights, which represent which bone transforms affect the matrix, and by how much. The weights add up to 1.0 per vertex. So that the weights and IDs can be sent more easily to the shader as a vec4 and an ivec4, models usually limit the number of bones that affect a vertex to 4. So that the shader’s vertex inputs look like this: layout(location = 0) in vec3 inPos; layout(location = 1) in vec3 inNormal; layout(location = 2) in vec2 inTexCoord; layout(location = 3) in ivec4 inBoneIDs; //which bone matricies to use layout(location = 4) in vec4 inWeights; //how much it affects I add up each bone matrix into one big ‘skin’ matrix and apply it to the vertex to get it into bone space. This is also applied to the normal to ensure lighting calculations account for the animation. mat4 skin = mat4(0.0f); for(int i = 0; i &lt; 4; i++) { if(inBoneIDs[i] == -1 || inBoneIDs[i] &gt;= MAX_BONES) break; skin += inWeights[i] * bones.mat[inBoneIDs[i]]; } // final_pos = projection * view * model * skin * position // final_normal = normal_matrix * skin * normal If the animation is updated each frame by the game loop to get new bone matricies, then the model will be animated by the shader." />
<meta property="og:description" content="I’ve added Skeletal animation to my Vulkan game framwork. I already use assimp to load in 3D models, but the library also loads animations if the model has them. I’ve revamped the model loading system to be able to load animated and non-animated models auutomically, and the renderer can take a model and an animation and render the current state of the animation to the screen. Vulkan Framwork Source Code Model I used: Wolf by 3D Haupt How it works The Animation is stored as a hierarchy of bones, where each bone has a number of keyframes for scale, position and rotation, and a parent bone. Each bone corresponds to a 4×4 transform matrix that transforms the verticies from local to bone space. These transform matricies are calculated each frame and applied in the shader. In my implementation I send a uniform that holds and array of bone transform matricies that can be accessed by the animated verticies. const int MAX_BONES = 50; layout(set = 2, binding = 0) uniform boneView { mat4 mat[MAX_BONES]; } bones; As the animation plays, the current frame’s bone matricies are calculated using the keyframes of each bone. When an animation timing lands between two keyframes, the state is linearly interpreted using the two surrounding frames and the time the animation is at. Furthermore each matrix is multiplied by it’s parent’s matrix so that, say, a hand will move if an arm moves, without having to specifically move the hand too. Each vertex on the model has a number of bone IDs and weights, which represent which bone transforms affect the matrix, and by how much. The weights add up to 1.0 per vertex. So that the weights and IDs can be sent more easily to the shader as a vec4 and an ivec4, models usually limit the number of bones that affect a vertex to 4. So that the shader’s vertex inputs look like this: layout(location = 0) in vec3 inPos; layout(location = 1) in vec3 inNormal; layout(location = 2) in vec2 inTexCoord; layout(location = 3) in ivec4 inBoneIDs; //which bone matricies to use layout(location = 4) in vec4 inWeights; //how much it affects I add up each bone matrix into one big ‘skin’ matrix and apply it to the vertex to get it into bone space. This is also applied to the normal to ensure lighting calculations account for the animation. mat4 skin = mat4(0.0f); for(int i = 0; i &lt; 4; i++) { if(inBoneIDs[i] == -1 || inBoneIDs[i] &gt;= MAX_BONES) break; skin += inWeights[i] * bones.mat[inBoneIDs[i]]; } // final_pos = projection * view * model * skin * position // final_normal = normal_matrix * skin * normal If the animation is updated each frame by the game loop to get new bone matricies, then the model will be animated by the shader." />
<link rel="canonical" href="http://localhost:4000/demo/2022/06/28/3D-Skeletal-Animation.html" />
<meta property="og:url" content="http://localhost:4000/demo/2022/06/28/3D-Skeletal-Animation.html" />
<meta property="og:site_name" content="NoamZeise" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-06-28T00:00:00+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="3D Skeletal Animation With Vulkan" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-06-28T00:00:00+01:00","datePublished":"2022-06-28T00:00:00+01:00","description":"I’ve added Skeletal animation to my Vulkan game framwork. I already use assimp to load in 3D models, but the library also loads animations if the model has them. I’ve revamped the model loading system to be able to load animated and non-animated models auutomically, and the renderer can take a model and an animation and render the current state of the animation to the screen. Vulkan Framwork Source Code Model I used: Wolf by 3D Haupt How it works The Animation is stored as a hierarchy of bones, where each bone has a number of keyframes for scale, position and rotation, and a parent bone. Each bone corresponds to a 4×4 transform matrix that transforms the verticies from local to bone space. These transform matricies are calculated each frame and applied in the shader. In my implementation I send a uniform that holds and array of bone transform matricies that can be accessed by the animated verticies. const int MAX_BONES = 50; layout(set = 2, binding = 0) uniform boneView { mat4 mat[MAX_BONES]; } bones; As the animation plays, the current frame’s bone matricies are calculated using the keyframes of each bone. When an animation timing lands between two keyframes, the state is linearly interpreted using the two surrounding frames and the time the animation is at. Furthermore each matrix is multiplied by it’s parent’s matrix so that, say, a hand will move if an arm moves, without having to specifically move the hand too. Each vertex on the model has a number of bone IDs and weights, which represent which bone transforms affect the matrix, and by how much. The weights add up to 1.0 per vertex. So that the weights and IDs can be sent more easily to the shader as a vec4 and an ivec4, models usually limit the number of bones that affect a vertex to 4. So that the shader’s vertex inputs look like this: layout(location = 0) in vec3 inPos; layout(location = 1) in vec3 inNormal; layout(location = 2) in vec2 inTexCoord; layout(location = 3) in ivec4 inBoneIDs; //which bone matricies to use layout(location = 4) in vec4 inWeights; //how much it affects I add up each bone matrix into one big ‘skin’ matrix and apply it to the vertex to get it into bone space. This is also applied to the normal to ensure lighting calculations account for the animation. mat4 skin = mat4(0.0f); for(int i = 0; i &lt; 4; i++) { if(inBoneIDs[i] == -1 || inBoneIDs[i] &gt;= MAX_BONES) break; skin += inWeights[i] * bones.mat[inBoneIDs[i]]; } // final_pos = projection * view * model * skin * position // final_normal = normal_matrix * skin * normal If the animation is updated each frame by the game loop to get new bone matricies, then the model will be animated by the shader.","headline":"3D Skeletal Animation With Vulkan","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/demo/2022/06/28/3D-Skeletal-Animation.html"},"url":"http://localhost:4000/demo/2022/06/28/3D-Skeletal-Animation.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="NoamZeise" />
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">NoamZeise</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
	  <a class="page-link" href="https://github.com/NoamZeise">GitHub</a>
	  <a class="page-link" href="https://noamzeise.itch.io/">Itch.io</a><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">3D Skeletal Animation With Vulkan</h1>
    <p class="post-meta"><time class="dt-published" datetime="2022-06-28T00:00:00+01:00" itemprop="datePublished">
        Jun 28, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <iframe width="560" height="315" src="https://www.youtube.com/embed/kic2IAvDSM8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>

<p>I’ve added Skeletal animation to my Vulkan game framwork. I already use assimp to load in 3D models,
but the library also loads animations if the model has them.
I’ve revamped the model loading system to be able to load animated and non-animated 
models auutomically, and the renderer can take a model and an animation 
and render the current state of the animation to the screen.</p>

<p><a href="https://github.com/NoamZeise/Vulkan-Environment">Vulkan Framwork Source Code</a></p>

<p><a href="https://free3d.com/3d-model/wolf-rigged-and-game-ready-42808.html">Model I used: Wolf by 3D Haupt</a></p>

<h2 id="how-it-works">How it works</h2>

<p>The Animation is stored as a hierarchy of bones, where each bone has a number of keyframes for scale, position and rotation, and a parent bone.</p>

<p>Each bone corresponds to a 4×4 transform matrix that transforms the verticies from local to bone space. These transform matricies are calculated each frame and applied in the shader. In my implementation I send a uniform that holds and array of bone transform matricies that can be accessed by the animated verticies.</p>
<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">MAX_BONES</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
<span class="k">layout</span><span class="p">(</span><span class="n">set</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">binding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">uniform</span> <span class="n">boneView</span>
<span class="p">{</span>
   <span class="kt">mat4</span> <span class="n">mat</span><span class="p">[</span><span class="n">MAX_BONES</span><span class="p">];</span>
<span class="p">}</span> <span class="n">bones</span><span class="p">;</span>
</code></pre></div></div>
<p>As the animation plays, the current frame’s bone matricies are calculated using the keyframes of each bone. When an animation timing lands between two keyframes, the state is linearly interpreted using the two surrounding frames and the time the animation is at. Furthermore each matrix is multiplied by it’s parent’s matrix so that, say, a hand will move if an arm moves, without having to specifically move the hand too.</p>

<p>Each vertex on the model has a number of bone IDs and weights, which represent which bone transforms affect the matrix, and by how much. The weights add up to 1.0 per vertex.</p>

<p>So that the weights and IDs can be sent more easily to the shader as a vec4 and an ivec4, models usually limit the number of bones that affect a vertex to 4. So that the shader’s vertex inputs look like this:</p>
<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec3</span> <span class="n">inPos</span><span class="p">;</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec3</span> <span class="n">inNormal</span><span class="p">;</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec2</span> <span class="n">inTexCoord</span><span class="p">;</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">in</span> <span class="kt">ivec4</span> <span class="n">inBoneIDs</span><span class="p">;</span> <span class="c1">//which bone matricies to use</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec4</span> <span class="n">inWeights</span><span class="p">;</span> <span class="c1">//how much it affects</span>
</code></pre></div></div>
<p>I add up each bone matrix into one big ‘skin’ matrix and apply it to the vertex to get it into bone space. This is also applied to the normal to ensure lighting calculations account for the animation.</p>
<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">mat4</span> <span class="n">skin</span> <span class="o">=</span> <span class="kt">mat4</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
   <span class="k">if</span><span class="p">(</span><span class="n">inBoneIDs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">inBoneIDs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">MAX_BONES</span><span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
   <span class="n">skin</span> <span class="o">+=</span> <span class="n">inWeights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">bones</span><span class="p">.</span><span class="n">mat</span><span class="p">[</span><span class="n">inBoneIDs</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
<span class="p">}</span>

<span class="c1">// final_pos = projection * view * model * skin * position</span>
<span class="c1">// final_normal = normal_matrix * skin * normal</span>
</code></pre></div></div>
<p>If the animation is updated each frame by the game loop to get new bone matricies, 
then the model will be animated by the shader.</p>

  </div><a class="u-url" href="/demo/2022/06/28/3D-Skeletal-Animation.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">

</footer>
</body>

</html>
