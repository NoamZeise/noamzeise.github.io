<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>ZL001 - Assembly Programming Game | NoamZeise</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="ZL001 - Assembly Programming Game" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Source Code + Build on Github The news that puzzle game studio zachtronics would stop making games inspired me to begin creating a little game in the style of some of their programming games (TS100, ShenzenIO, Exapunks). I’m using this project to play about with a library(SDL2) and a language(Rust) I haven’t used for games before. I’ve been working on it slowly and I have some of the more basic mechanics in a playable form. The game has a custom text editor and a circuit creation gui. It doesn’t have any levels yet, instead it works as a sandbox. The GUI handles writing code, placing/deleting microcontrollers, connecting IO ports together, saving/loading and compiling/stepping the code. The shell shows the state of the registers after every execution step and any compile errors. As you can see from the video the circuit designer lets you place microcontrollers and connect up their IO ports. They can then be programmed to do whatever is desired. The code can be stepped through and the shell shows which values are in each of the registers, as well as if the microcontroller is waiting for an io port. The Language The language is not accurate assembly, it does not correspond one to one with a binary format, it is inspired by the languages from zachtronic games, as well as other fake assembly langauges like Sigma16. What makes it unique from the usual zach-like languages is that code lables are just converted to numbers, so register, direct addresses, inputs can all be used as branch destinations. Another difference is that the program counter is treated as a normal register that the programmer can manipulate, which would make it possible to have simple functions. The langauge is made up of a series of instructions, which are for: maths -&gt; ADD, SUB, MUL, DIV branching -&gt; CMP, BRC, BEQ, BGT, BLT no operation -&gt; NOP halt -&gt; HLT Each instruction can be followed by up to three operands depending on the instruction. An operand is a value (which includes lables), or a register. Each microcontroller has 4 normal register and 4 IO registers. The registers are: PC -&gt; Program Counter RT -&gt; Test register (holds CMP flags) R1, R2 -&gt; General Registers IO0, IO1, IO2, IO3 -&gt; IO registers, can be read to or written from (blocks until another microcontroller read/writes the value) Experience with SDL2 and Rust I found SDL2 to be pretty unintuitive compared to frameworks like Monogame, I had to look at a lot of example code and check the source code to see what it was doing. I didn’t like the system of a canvas being passed around. The Rust borrow checker also meant that a lot of types that rely on the sdl2 lifetime needed to have explicit lifetimes. Once I had made a few helper functions in place to handle texture/font loading and drawing it became a lot more managable. I moved the sdl2 resources to resource managers and just exposed cheap representations of the resource to the rest of the game. I found Rust to be enjoyable to use, but I definitely found myself missing some of the freedom that comes with C++. The amount of string parsing functions that Rust has, the easy to use iterator system, and the pattern match syntax, made this specific program fun to code. I found being thorough with my error checking to be much easier with rust, as it really encourages you to handle errors, instead of having to remember to do it yourself. What’s next The next stage of this project would be to add in input and output devices that would give the user some sort of puzzle to complete with the provided sandbox, as in a zach-like game. But for now I will be putting this on hold to work on other things. I will have to overhaul the rendering, to make it more friendly for resolution scaling." />
<meta property="og:description" content="Source Code + Build on Github The news that puzzle game studio zachtronics would stop making games inspired me to begin creating a little game in the style of some of their programming games (TS100, ShenzenIO, Exapunks). I’m using this project to play about with a library(SDL2) and a language(Rust) I haven’t used for games before. I’ve been working on it slowly and I have some of the more basic mechanics in a playable form. The game has a custom text editor and a circuit creation gui. It doesn’t have any levels yet, instead it works as a sandbox. The GUI handles writing code, placing/deleting microcontrollers, connecting IO ports together, saving/loading and compiling/stepping the code. The shell shows the state of the registers after every execution step and any compile errors. As you can see from the video the circuit designer lets you place microcontrollers and connect up their IO ports. They can then be programmed to do whatever is desired. The code can be stepped through and the shell shows which values are in each of the registers, as well as if the microcontroller is waiting for an io port. The Language The language is not accurate assembly, it does not correspond one to one with a binary format, it is inspired by the languages from zachtronic games, as well as other fake assembly langauges like Sigma16. What makes it unique from the usual zach-like languages is that code lables are just converted to numbers, so register, direct addresses, inputs can all be used as branch destinations. Another difference is that the program counter is treated as a normal register that the programmer can manipulate, which would make it possible to have simple functions. The langauge is made up of a series of instructions, which are for: maths -&gt; ADD, SUB, MUL, DIV branching -&gt; CMP, BRC, BEQ, BGT, BLT no operation -&gt; NOP halt -&gt; HLT Each instruction can be followed by up to three operands depending on the instruction. An operand is a value (which includes lables), or a register. Each microcontroller has 4 normal register and 4 IO registers. The registers are: PC -&gt; Program Counter RT -&gt; Test register (holds CMP flags) R1, R2 -&gt; General Registers IO0, IO1, IO2, IO3 -&gt; IO registers, can be read to or written from (blocks until another microcontroller read/writes the value) Experience with SDL2 and Rust I found SDL2 to be pretty unintuitive compared to frameworks like Monogame, I had to look at a lot of example code and check the source code to see what it was doing. I didn’t like the system of a canvas being passed around. The Rust borrow checker also meant that a lot of types that rely on the sdl2 lifetime needed to have explicit lifetimes. Once I had made a few helper functions in place to handle texture/font loading and drawing it became a lot more managable. I moved the sdl2 resources to resource managers and just exposed cheap representations of the resource to the rest of the game. I found Rust to be enjoyable to use, but I definitely found myself missing some of the freedom that comes with C++. The amount of string parsing functions that Rust has, the easy to use iterator system, and the pattern match syntax, made this specific program fun to code. I found being thorough with my error checking to be much easier with rust, as it really encourages you to handle errors, instead of having to remember to do it yourself. What’s next The next stage of this project would be to add in input and output devices that would give the user some sort of puzzle to complete with the provided sandbox, as in a zach-like game. But for now I will be putting this on hold to work on other things. I will have to overhaul the rendering, to make it more friendly for resolution scaling." />
<link rel="canonical" href="http://localhost:4000/game/2022/07/31/ZL100.html" />
<meta property="og:url" content="http://localhost:4000/game/2022/07/31/ZL100.html" />
<meta property="og:site_name" content="NoamZeise" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-07-31T00:00:00+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="ZL001 - Assembly Programming Game" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-07-31T00:00:00+01:00","datePublished":"2022-07-31T00:00:00+01:00","description":"Source Code + Build on Github The news that puzzle game studio zachtronics would stop making games inspired me to begin creating a little game in the style of some of their programming games (TS100, ShenzenIO, Exapunks). I’m using this project to play about with a library(SDL2) and a language(Rust) I haven’t used for games before. I’ve been working on it slowly and I have some of the more basic mechanics in a playable form. The game has a custom text editor and a circuit creation gui. It doesn’t have any levels yet, instead it works as a sandbox. The GUI handles writing code, placing/deleting microcontrollers, connecting IO ports together, saving/loading and compiling/stepping the code. The shell shows the state of the registers after every execution step and any compile errors. As you can see from the video the circuit designer lets you place microcontrollers and connect up their IO ports. They can then be programmed to do whatever is desired. The code can be stepped through and the shell shows which values are in each of the registers, as well as if the microcontroller is waiting for an io port. The Language The language is not accurate assembly, it does not correspond one to one with a binary format, it is inspired by the languages from zachtronic games, as well as other fake assembly langauges like Sigma16. What makes it unique from the usual zach-like languages is that code lables are just converted to numbers, so register, direct addresses, inputs can all be used as branch destinations. Another difference is that the program counter is treated as a normal register that the programmer can manipulate, which would make it possible to have simple functions. The langauge is made up of a series of instructions, which are for: maths -&gt; ADD, SUB, MUL, DIV branching -&gt; CMP, BRC, BEQ, BGT, BLT no operation -&gt; NOP halt -&gt; HLT Each instruction can be followed by up to three operands depending on the instruction. An operand is a value (which includes lables), or a register. Each microcontroller has 4 normal register and 4 IO registers. The registers are: PC -&gt; Program Counter RT -&gt; Test register (holds CMP flags) R1, R2 -&gt; General Registers IO0, IO1, IO2, IO3 -&gt; IO registers, can be read to or written from (blocks until another microcontroller read/writes the value) Experience with SDL2 and Rust I found SDL2 to be pretty unintuitive compared to frameworks like Monogame, I had to look at a lot of example code and check the source code to see what it was doing. I didn’t like the system of a canvas being passed around. The Rust borrow checker also meant that a lot of types that rely on the sdl2 lifetime needed to have explicit lifetimes. Once I had made a few helper functions in place to handle texture/font loading and drawing it became a lot more managable. I moved the sdl2 resources to resource managers and just exposed cheap representations of the resource to the rest of the game. I found Rust to be enjoyable to use, but I definitely found myself missing some of the freedom that comes with C++. The amount of string parsing functions that Rust has, the easy to use iterator system, and the pattern match syntax, made this specific program fun to code. I found being thorough with my error checking to be much easier with rust, as it really encourages you to handle errors, instead of having to remember to do it yourself. What’s next The next stage of this project would be to add in input and output devices that would give the user some sort of puzzle to complete with the provided sandbox, as in a zach-like game. But for now I will be putting this on hold to work on other things. I will have to overhaul the rendering, to make it more friendly for resolution scaling.","headline":"ZL001 - Assembly Programming Game","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/game/2022/07/31/ZL100.html"},"url":"http://localhost:4000/game/2022/07/31/ZL100.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="NoamZeise" />
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">NoamZeise</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
	  <a class="page-link" href="https://github.com/NoamZeise">GitHub</a>
	  <a class="page-link" href="https://noamzeise.itch.io/">Itch.io</a><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">ZL001 - Assembly Programming Game</h1>
    <p class="post-meta"><time class="dt-published" datetime="2022-07-31T00:00:00+01:00" itemprop="datePublished">
        Jul 31, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <iframe width="560" height="315" src="https://www.youtube.com/embed/lzEfdocz_m0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>

<p><br />
<a href="https://github.com/NoamZeise/ZL001">Source Code + Build on Github</a>
<br />
The news that puzzle game studio <a href="https://www.zachtronics.com/">zachtronics</a> would stop making games inspired me to begin 
creating a little game in the style of some of their programming games (<a href="https://www.zachtronics.com/tis-100/">TS100</a>, <a href="https://www.zachtronics.com/shenzhen-io/">ShenzenIO</a>, <a href="https://www.zachtronics.com/exapunks/">Exapunks</a>).
I’m using this project to play about with a library(<a href="https://github.com/Rust-SDL2/rust-sdl2">SDL2</a>) and a language(Rust) I haven’t used for games before. 
I’ve been working on it slowly and I have some of the more basic mechanics 
in a playable form.</p>

<p><img src="/assets/img/posts/ZL001Old/zl001-ss.png" /></p>

<p>The game has a custom text editor and a circuit creation gui. It doesn’t have any levels yet, 
instead it works as a sandbox. 
The GUI handles writing code, placing/deleting microcontrollers,
connecting IO ports together, saving/loading and compiling/stepping the code. 
The shell shows the state of the registers after every execution step and any compile errors.</p>

<p>As you can see from the video the circuit designer lets you place microcontrollers and connect up 
their IO ports. They can then be programmed to do whatever is desired. 
The code can be stepped through and the shell shows which values are in each of the registers,
as well as if the microcontroller is waiting for an io port.</p>

<h2 id="the-language">The Language</h2>

<p><img src="/assets/img/posts/ZL001Old/zlo001-ss2.png" /></p>

<p>The language is not accurate assembly, it does not correspond one to one with a binary format, it is inspired by the languages from zachtronic games, as well as other fake assembly langauges like Sigma16.</p>

<p>What makes it unique from the usual zach-like languages is that code lables are just converted to numbers, so register, direct addresses, inputs can all be used as branch destinations. Another difference is that the program counter is treated as a normal register that the programmer can manipulate, which would make it possible to have simple functions.</p>

<p>The langauge is made up of a series of instructions, which are for:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>maths -&gt; ADD, SUB, MUL, DIV
branching -&gt; CMP, BRC, BEQ, BGT, BLT
no operation -&gt; NOP
halt -&gt; HLT
</code></pre></div></div>

<p>Each instruction can be followed by up to three operands depending on the instruction.</p>

<p>An operand is a value (which includes lables), or a register. Each microcontroller has 4 normal register and 4 IO registers.</p>

<p>The registers are:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PC -&gt; Program Counter
RT -&gt; Test register (holds CMP flags)
R1, R2 -&gt; General Registers
IO0, IO1, IO2, IO3 -&gt; IO registers, can be read to or written from (blocks until another microcontroller read/writes the value)
</code></pre></div></div>

<h2 id="experience-with-sdl2-and-rust">Experience with SDL2 and Rust</h2>

<p>I found SDL2 to be pretty unintuitive compared to frameworks like Monogame, I had to look at a lot of example code and check the source code to see what it was doing. I didn’t like the system of a canvas being passed around. The Rust borrow checker also meant that a lot of types that rely on the sdl2 lifetime needed to have explicit lifetimes.</p>

<p>Once I had made a few helper functions in place to handle texture/font loading and drawing it became a lot more managable. I moved the sdl2 resources to resource managers and just exposed cheap representations of the resource to the rest of the game. I found Rust to be enjoyable to use, but I definitely found myself missing some of the freedom that comes with C++.</p>

<p>The amount of string parsing functions that Rust has, the easy to use iterator system, and the pattern match syntax, made this specific program fun to code. I found being thorough with my error checking to be much easier with rust, as it really encourages you to handle errors, instead of having to remember to do it yourself.</p>

<h2 id="whats-next">What’s next</h2>

<p>The next stage of this project would be to add in input and output devices that would give the user some sort of puzzle to complete with the provided sandbox, as in a zach-like game. But for now I will be putting this on hold to work on other things. I will have to overhaul the rendering, to make it more friendly for resolution scaling.</p>

  </div><a class="u-url" href="/game/2022/07/31/ZL100.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">

</footer>
</body>

</html>
