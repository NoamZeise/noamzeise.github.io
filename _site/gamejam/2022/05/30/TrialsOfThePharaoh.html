<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Trials Of The Pharaoh - Light Ray Puzzle Game | NoamZeise</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Trials Of The Pharaoh - Light Ray Puzzle Game" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="An Egyptian light ray puzzle game, made in 10 days for GDTV Jam 2022 with my Vulkan and OpenGL graphics libraries. I worked together with the same people that made The Last Dodo with me. This is the first project where I have both a Vulkan and an OpenGL executable, this ensures that those with older gpus or outdated drivers will still be able to play (before I had a few people complaing about the game not working for them). Out of 950 submissions, we managed to get 1st place in both the “fun” and “music” categories, 4th in “Mechanics” and “Sound”, and 5th in “Aesthetics”. Which I am very happy with. download on itch.io view source code on github Credits: Mick Cooke – MakeFire Music - Music Thanos Gramosis - Art Paul James – Wafer Audio - Sound Paulina Ramirez – Lady Yami #3939 - Voice Over/Writing Noam Zeise - Programming Technical Details: 2D Light Ray Shader Shaders played a big role in this game, the light ray effect is generated by the fragment shader. The rays begin from an emitter, and shoot out into the game map. The map is stored as a series of lines, so a square will have 4 lines for example. I step forward by a large amount of units and check each surface to see if the ray intersected any lines, if it did, I roll back the ray to half the previous step and check again. If there was still a collision I go half again back, if not, I go half again forward. This is repeat until the ray is at the desired detail level. If the surface is a mirror, the ray is reflected based on the laws of reflection and I repeat the above steps, until I have a series of start and end points for rays. There is a cutoff of reflections to prevent an infinite loop, and to ensure the shader buffer isn’t exceeded. The array of start and end points are converted from game coords to screen coords, then sent to a storage buffer on the gpu at the start of the frame. these points are accessed from the fragment shader, which modify the brightness of a pixel based on how close each fragment is to a line. The intensity is also modified by time with a sine function to give the rays a “pulsing” effect in the direction of travel. The light ray shader takes in an array of pairs of points and a distance that I store in a shader buffer. I calculate the distance on the cpu so that it does not need to be recalculated for each fragment. const int RAY_COUNT = 100; layout(set = 4, binding = 0) readonly buffer PerFrameLightPoints{ vec2 p1; vec2 p2; float distance; } rays[RAY_COUNT]; I also send in a time value that I use to produce the wave effect the light has. layout(location = 2) in float time; I calculate the value of the fragment by summing the effect of each ray into an attenuation value that I use to modify the colour towards yellow. The closer the fragment is to the line between the two points, the brighter it is. vec4 col = texture(sampler2D(textures[texID], texSamp), coord) * colour; float attenuation = 0.0f; // add to the attenuation the effects of each ray on the fragment for(int i = 0; i &lt; RAY_COUNT; i++) { // I set the last ray distance to zero to break the loop early if(rays[i].distance == 0) break; float dist = 0.0f; // Get the square distance from the start point to the end point vec2 lineVec = (rays[i].p2 - rays[i].p1); float l2 = (lineVec.x* lineVec.x) + (lineVec.y*lineVec.y); // If the ray has no length, we calculate the distance // from the start point to the fragment if(l2 == 0.0f) dist = distance(rays[i].p1, gl_FragCoord.xy); // Otherwise we calc the distance from the fragment // and the line between the two points by projecting the // fragment onto the line and getting the distance between // that point and the fragment pos else { float t = max(0, min(1, dot(gl_FragCoord.xy - rays[i].p1, rays[i].p2 - rays[i].p1) / l2)); vec2 projection = rays[i].p1 + (rays[i].p2 - rays[i].p1)*t; float fromStart = distance(rays[i].p1, gl_FragCoord.xy); // add a sinusoidal wave effect to the light over time float correction = abs(sin(fromStart * 0.01f - time))*0.5f + 0.3f; dist = distance(gl_FragCoord.xy, projection) / correction; } attenuation += 1.0f / (1.0f + 0.3f * dist + 0.05f * dist * dist); } // add yellow to the colour based on the effect of the light rays col += vec4(1.0f, 1.0f, 0.7882352941f, 0.0f) * attenuation; Vulkan and OpenGL differences I used preprocessor directives to include either version of the graphics libraries (which have identical outward-facing APIs) (Now I am using volk which means I don’t statically link to vulkan, so I only have 1 binary). This builds two versions of the game, which isn’t ideal in terms of file size, as it adds 1.8MB to the download. The binaries can use the same folders for textures, audio, and other resources (but they both need their own shaders as OpenGL glsl is a little different from Vulkan glsl). Both versions look almost identical on my hardware: Vulkan: OpenGL: The major difference can be seem in the text, it looks sharper and blockier to me in OpenGL, I expect this is down to the difference in how each rendering pipeline is set up. My Vulkan library draws it’s rendered image to a quad which is then scaled to fit the screen backbuffer. The OpenGL implimentation just directly draws on the screen buffer, modifying the draws to account for the backbuffer size." />
<meta property="og:description" content="An Egyptian light ray puzzle game, made in 10 days for GDTV Jam 2022 with my Vulkan and OpenGL graphics libraries. I worked together with the same people that made The Last Dodo with me. This is the first project where I have both a Vulkan and an OpenGL executable, this ensures that those with older gpus or outdated drivers will still be able to play (before I had a few people complaing about the game not working for them). Out of 950 submissions, we managed to get 1st place in both the “fun” and “music” categories, 4th in “Mechanics” and “Sound”, and 5th in “Aesthetics”. Which I am very happy with. download on itch.io view source code on github Credits: Mick Cooke – MakeFire Music - Music Thanos Gramosis - Art Paul James – Wafer Audio - Sound Paulina Ramirez – Lady Yami #3939 - Voice Over/Writing Noam Zeise - Programming Technical Details: 2D Light Ray Shader Shaders played a big role in this game, the light ray effect is generated by the fragment shader. The rays begin from an emitter, and shoot out into the game map. The map is stored as a series of lines, so a square will have 4 lines for example. I step forward by a large amount of units and check each surface to see if the ray intersected any lines, if it did, I roll back the ray to half the previous step and check again. If there was still a collision I go half again back, if not, I go half again forward. This is repeat until the ray is at the desired detail level. If the surface is a mirror, the ray is reflected based on the laws of reflection and I repeat the above steps, until I have a series of start and end points for rays. There is a cutoff of reflections to prevent an infinite loop, and to ensure the shader buffer isn’t exceeded. The array of start and end points are converted from game coords to screen coords, then sent to a storage buffer on the gpu at the start of the frame. these points are accessed from the fragment shader, which modify the brightness of a pixel based on how close each fragment is to a line. The intensity is also modified by time with a sine function to give the rays a “pulsing” effect in the direction of travel. The light ray shader takes in an array of pairs of points and a distance that I store in a shader buffer. I calculate the distance on the cpu so that it does not need to be recalculated for each fragment. const int RAY_COUNT = 100; layout(set = 4, binding = 0) readonly buffer PerFrameLightPoints{ vec2 p1; vec2 p2; float distance; } rays[RAY_COUNT]; I also send in a time value that I use to produce the wave effect the light has. layout(location = 2) in float time; I calculate the value of the fragment by summing the effect of each ray into an attenuation value that I use to modify the colour towards yellow. The closer the fragment is to the line between the two points, the brighter it is. vec4 col = texture(sampler2D(textures[texID], texSamp), coord) * colour; float attenuation = 0.0f; // add to the attenuation the effects of each ray on the fragment for(int i = 0; i &lt; RAY_COUNT; i++) { // I set the last ray distance to zero to break the loop early if(rays[i].distance == 0) break; float dist = 0.0f; // Get the square distance from the start point to the end point vec2 lineVec = (rays[i].p2 - rays[i].p1); float l2 = (lineVec.x* lineVec.x) + (lineVec.y*lineVec.y); // If the ray has no length, we calculate the distance // from the start point to the fragment if(l2 == 0.0f) dist = distance(rays[i].p1, gl_FragCoord.xy); // Otherwise we calc the distance from the fragment // and the line between the two points by projecting the // fragment onto the line and getting the distance between // that point and the fragment pos else { float t = max(0, min(1, dot(gl_FragCoord.xy - rays[i].p1, rays[i].p2 - rays[i].p1) / l2)); vec2 projection = rays[i].p1 + (rays[i].p2 - rays[i].p1)*t; float fromStart = distance(rays[i].p1, gl_FragCoord.xy); // add a sinusoidal wave effect to the light over time float correction = abs(sin(fromStart * 0.01f - time))*0.5f + 0.3f; dist = distance(gl_FragCoord.xy, projection) / correction; } attenuation += 1.0f / (1.0f + 0.3f * dist + 0.05f * dist * dist); } // add yellow to the colour based on the effect of the light rays col += vec4(1.0f, 1.0f, 0.7882352941f, 0.0f) * attenuation; Vulkan and OpenGL differences I used preprocessor directives to include either version of the graphics libraries (which have identical outward-facing APIs) (Now I am using volk which means I don’t statically link to vulkan, so I only have 1 binary). This builds two versions of the game, which isn’t ideal in terms of file size, as it adds 1.8MB to the download. The binaries can use the same folders for textures, audio, and other resources (but they both need their own shaders as OpenGL glsl is a little different from Vulkan glsl). Both versions look almost identical on my hardware: Vulkan: OpenGL: The major difference can be seem in the text, it looks sharper and blockier to me in OpenGL, I expect this is down to the difference in how each rendering pipeline is set up. My Vulkan library draws it’s rendered image to a quad which is then scaled to fit the screen backbuffer. The OpenGL implimentation just directly draws on the screen buffer, modifying the draws to account for the backbuffer size." />
<link rel="canonical" href="http://localhost:4000/gamejam/2022/05/30/TrialsOfThePharaoh.html" />
<meta property="og:url" content="http://localhost:4000/gamejam/2022/05/30/TrialsOfThePharaoh.html" />
<meta property="og:site_name" content="NoamZeise" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-05-30T00:00:00+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Trials Of The Pharaoh - Light Ray Puzzle Game" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-05-30T00:00:00+01:00","datePublished":"2022-05-30T00:00:00+01:00","description":"An Egyptian light ray puzzle game, made in 10 days for GDTV Jam 2022 with my Vulkan and OpenGL graphics libraries. I worked together with the same people that made The Last Dodo with me. This is the first project where I have both a Vulkan and an OpenGL executable, this ensures that those with older gpus or outdated drivers will still be able to play (before I had a few people complaing about the game not working for them). Out of 950 submissions, we managed to get 1st place in both the “fun” and “music” categories, 4th in “Mechanics” and “Sound”, and 5th in “Aesthetics”. Which I am very happy with. download on itch.io view source code on github Credits: Mick Cooke – MakeFire Music - Music Thanos Gramosis - Art Paul James – Wafer Audio - Sound Paulina Ramirez – Lady Yami #3939 - Voice Over/Writing Noam Zeise - Programming Technical Details: 2D Light Ray Shader Shaders played a big role in this game, the light ray effect is generated by the fragment shader. The rays begin from an emitter, and shoot out into the game map. The map is stored as a series of lines, so a square will have 4 lines for example. I step forward by a large amount of units and check each surface to see if the ray intersected any lines, if it did, I roll back the ray to half the previous step and check again. If there was still a collision I go half again back, if not, I go half again forward. This is repeat until the ray is at the desired detail level. If the surface is a mirror, the ray is reflected based on the laws of reflection and I repeat the above steps, until I have a series of start and end points for rays. There is a cutoff of reflections to prevent an infinite loop, and to ensure the shader buffer isn’t exceeded. The array of start and end points are converted from game coords to screen coords, then sent to a storage buffer on the gpu at the start of the frame. these points are accessed from the fragment shader, which modify the brightness of a pixel based on how close each fragment is to a line. The intensity is also modified by time with a sine function to give the rays a “pulsing” effect in the direction of travel. The light ray shader takes in an array of pairs of points and a distance that I store in a shader buffer. I calculate the distance on the cpu so that it does not need to be recalculated for each fragment. const int RAY_COUNT = 100; layout(set = 4, binding = 0) readonly buffer PerFrameLightPoints{ vec2 p1; vec2 p2; float distance; } rays[RAY_COUNT]; I also send in a time value that I use to produce the wave effect the light has. layout(location = 2) in float time; I calculate the value of the fragment by summing the effect of each ray into an attenuation value that I use to modify the colour towards yellow. The closer the fragment is to the line between the two points, the brighter it is. vec4 col = texture(sampler2D(textures[texID], texSamp), coord) * colour; float attenuation = 0.0f; // add to the attenuation the effects of each ray on the fragment for(int i = 0; i &lt; RAY_COUNT; i++) { // I set the last ray distance to zero to break the loop early if(rays[i].distance == 0) break; float dist = 0.0f; // Get the square distance from the start point to the end point vec2 lineVec = (rays[i].p2 - rays[i].p1); float l2 = (lineVec.x* lineVec.x) + (lineVec.y*lineVec.y); // If the ray has no length, we calculate the distance // from the start point to the fragment if(l2 == 0.0f) dist = distance(rays[i].p1, gl_FragCoord.xy); // Otherwise we calc the distance from the fragment // and the line between the two points by projecting the // fragment onto the line and getting the distance between // that point and the fragment pos else { float t = max(0, min(1, dot(gl_FragCoord.xy - rays[i].p1, rays[i].p2 - rays[i].p1) / l2)); vec2 projection = rays[i].p1 + (rays[i].p2 - rays[i].p1)*t; float fromStart = distance(rays[i].p1, gl_FragCoord.xy); // add a sinusoidal wave effect to the light over time float correction = abs(sin(fromStart * 0.01f - time))*0.5f + 0.3f; dist = distance(gl_FragCoord.xy, projection) / correction; } attenuation += 1.0f / (1.0f + 0.3f * dist + 0.05f * dist * dist); } // add yellow to the colour based on the effect of the light rays col += vec4(1.0f, 1.0f, 0.7882352941f, 0.0f) * attenuation; Vulkan and OpenGL differences I used preprocessor directives to include either version of the graphics libraries (which have identical outward-facing APIs) (Now I am using volk which means I don’t statically link to vulkan, so I only have 1 binary). This builds two versions of the game, which isn’t ideal in terms of file size, as it adds 1.8MB to the download. The binaries can use the same folders for textures, audio, and other resources (but they both need their own shaders as OpenGL glsl is a little different from Vulkan glsl). Both versions look almost identical on my hardware: Vulkan: OpenGL: The major difference can be seem in the text, it looks sharper and blockier to me in OpenGL, I expect this is down to the difference in how each rendering pipeline is set up. My Vulkan library draws it’s rendered image to a quad which is then scaled to fit the screen backbuffer. The OpenGL implimentation just directly draws on the screen buffer, modifying the draws to account for the backbuffer size.","headline":"Trials Of The Pharaoh - Light Ray Puzzle Game","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/gamejam/2022/05/30/TrialsOfThePharaoh.html"},"url":"http://localhost:4000/gamejam/2022/05/30/TrialsOfThePharaoh.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="NoamZeise" />
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">NoamZeise</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
	  <a class="page-link" href="https://github.com/NoamZeise">GitHub</a>
	  <a class="page-link" href="https://noamzeise.itch.io/">Itch.io</a><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Trials Of The Pharaoh - Light Ray Puzzle Game</h1>
    <p class="post-meta"><time class="dt-published" datetime="2022-05-30T00:00:00+01:00" itemprop="datePublished">
        May 30, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <iframe width="560" height="315" src="https://www.youtube.com/embed/fsNIisWhVz8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>

<p>An Egyptian light ray puzzle game, made in 10 days for GDTV Jam 2022 with my Vulkan and OpenGL graphics libraries. I worked together with the same people that made The Last Dodo with me.</p>

<p>This is the first project where I have both a Vulkan and an OpenGL executable, this ensures that those with older gpus or outdated drivers will still be able to play (before I had a few people complaing about the game not working for them).</p>

<p>Out of 950 submissions, we managed to get 1st place in both the “fun” and “music” categories, 4th in “Mechanics” and “Sound”, and 5th in “Aesthetics”. Which I am very happy with.</p>

<p><a href="https://noamzeise.itch.io/pharaoh-trials">download on itch.io</a></p>

<p><a href="https://github.com/NoamZeise/TrailsOfThePharaoh">view source code on github</a></p>

<h4 id="credits">Credits:</h4>

<ul>
  <li>
    <p><a href="https://youtube.com/channel/UCs75GjfGdtTS-CekMJOGICA">Mick Cooke – MakeFire Music</a> - Music</p>
  </li>
  <li>
    <p><a href="https://www.artstation.com/tha-com-nos">Thanos Gramosis</a> - Art</p>
  </li>
  <li>
    <p>Paul James – Wafer Audio - Sound</p>
  </li>
  <li>
    <p>Paulina Ramirez –  Lady Yami #3939 - Voice Over/Writing</p>
  </li>
  <li>
    <p>Noam Zeise - Programming</p>
  </li>
</ul>

<h2 id="technical-details">Technical Details:</h2>

<p><strong>2D Light Ray Shader</strong></p>

<p>Shaders played a big role in this game, the light ray effect is generated 
by the fragment shader.</p>

<p>The rays begin from an emitter, and shoot out into the game map. The map is stored as a series of lines, so a square will have 4 lines for example.
I step forward by a large amount of units and check each surface to see if the ray intersected any lines, 
if it did, I roll back the ray to half the previous step and check again. If there was still a collision I go half again back, if not,
I go half again forward. This is repeat until the ray is at the desired detail level. 
If the surface is a mirror, the ray is reflected based on the laws of reflection and I repeat the above steps, 
until I have a series of start and end points for rays. There is a cutoff of reflections to prevent an infinite loop, and to ensure the shader buffer isn’t exceeded.</p>

<p>The array of start and end points are converted from game coords to screen coords, then sent to a storage buffer 
on the gpu at the start of the frame. these points are accessed from the fragment shader, 
which modify the brightness of a pixel based on how close each fragment is to a line. 
The intensity is also modified by time with a sine function to give the rays a “pulsing” effect in the direction of travel.</p>

<p><img src="/assets/img/posts/trialspharaoh/light-anim.webp" /></p>

<p>The light ray shader takes in an array of pairs of points and a distance 
that I store in a shader buffer. 
I calculate the distance on the cpu so that it does not need to be recalculated for each fragment.</p>
<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">RAY_COUNT</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="k">layout</span><span class="p">(</span><span class="n">set</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">binding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">readonly</span> <span class="n">buffer</span> <span class="n">PerFrameLightPoints</span><span class="p">{</span>
  <span class="kt">vec2</span> <span class="n">p1</span><span class="p">;</span>
  <span class="kt">vec2</span> <span class="n">p2</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">distance</span><span class="p">;</span>
<span class="p">}</span> <span class="n">rays</span><span class="p">[</span><span class="n">RAY_COUNT</span><span class="p">];</span>
</code></pre></div></div>
<p>I also send in a time value that I use to produce the wave effect the light has.</p>
<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">in</span> <span class="kt">float</span> <span class="n">time</span><span class="p">;</span>
</code></pre></div></div>

<p>I calculate the value of the fragment by summing the effect of each ray into 
an attenuation value that I use to modify the colour towards yellow. The closer the fragment
is to the line between the two points, the brighter it is.</p>
<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">vec4</span> <span class="n">col</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="kt">sampler2D</span><span class="p">(</span><span class="n">textures</span><span class="p">[</span><span class="n">texID</span><span class="p">],</span> <span class="n">texSamp</span><span class="p">),</span> <span class="n">coord</span><span class="p">)</span> <span class="o">*</span> <span class="n">colour</span><span class="p">;</span>

<span class="kt">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
<span class="c1">// add to the attenuation the effects of each ray on the fragment</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RAY_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">//  I set the last ray distance to zero to break the loop early</span>
	<span class="k">if</span><span class="p">(</span><span class="n">rays</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">distance</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">break</span><span class="p">;</span>
	
	<span class="kt">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
	<span class="c1">// Get the square distance from the start point to the end point</span>
	<span class="kt">vec2</span> <span class="n">lineVec</span> <span class="o">=</span> <span class="p">(</span><span class="n">rays</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p2</span> <span class="o">-</span> <span class="n">rays</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p1</span><span class="p">);</span>
	<span class="kt">float</span> <span class="n">l2</span> <span class="o">=</span> <span class="p">(</span><span class="n">lineVec</span><span class="p">.</span><span class="n">x</span><span class="o">*</span> <span class="n">lineVec</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">lineVec</span><span class="p">.</span><span class="n">y</span><span class="o">*</span><span class="n">lineVec</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
	<span class="c1">// If the ray has no length, we calculate the distance </span>
	<span class="c1">// from the start point to the fragment</span>
	<span class="k">if</span><span class="p">(</span><span class="n">l2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">)</span>
		<span class="n">dist</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span><span class="n">rays</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p1</span><span class="p">,</span> <span class="nb">gl_FragCoord</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
	<span class="c1">// Otherwise we calc the distance from the fragment </span>
	<span class="c1">// and the line between the two points by projecting the</span>
	<span class="c1">// fragment onto the line and getting the distance between</span>
	<span class="c1">// that point and the fragment pos</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="kt">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="nb">gl_FragCoord</span><span class="p">.</span><span class="n">xy</span> <span class="o">-</span> <span class="n">rays</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p1</span><span class="p">,</span> 
			<span class="n">rays</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p2</span> <span class="o">-</span> <span class="n">rays</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p1</span><span class="p">)</span> <span class="o">/</span> <span class="n">l2</span><span class="p">));</span>
		<span class="kt">vec2</span> <span class="n">projection</span> <span class="o">=</span> <span class="n">rays</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p1</span> <span class="o">+</span> <span class="p">(</span><span class="n">rays</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p2</span> <span class="o">-</span> <span class="n">rays</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p1</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="p">;</span>
		<span class="kt">float</span> <span class="n">fromStart</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span><span class="n">rays</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p1</span><span class="p">,</span> <span class="nb">gl_FragCoord</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
		<span class="c1">// add a sinusoidal wave effect to the light over time</span>
		<span class="kt">float</span> <span class="n">correction</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">fromStart</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mo">01</span><span class="n">f</span> <span class="o">-</span> <span class="n">time</span><span class="p">))</span><span class="o">*</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">3</span><span class="n">f</span><span class="p">;</span>
		<span class="n">dist</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span><span class="nb">gl_FragCoord</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">projection</span><span class="p">)</span> <span class="o">/</span> <span class="n">correction</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">attenuation</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">3</span><span class="n">f</span> <span class="o">*</span> <span class="n">dist</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mo">05</span><span class="n">f</span> <span class="o">*</span> <span class="n">dist</span> <span class="o">*</span> <span class="n">dist</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// add yellow to the colour based on the effect of the light rays</span>
<span class="n">col</span> <span class="o">+=</span> <span class="kt">vec4</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">7882352941</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">)</span> <span class="o">*</span> <span class="n">attenuation</span><span class="p">;</span>
</code></pre></div></div>
<p><br /><br />
<strong>Vulkan and OpenGL differences</strong></p>

<p>I used preprocessor directives to include either version of the graphics libraries (which have identical outward-facing APIs) 
(Now I am using volk which means I don’t statically link to vulkan, so I only have 1 binary).
This builds two versions of the game, which isn’t ideal in terms of file size, as it adds 1.8MB to the download. 
The binaries can use the same folders for textures, audio, and other resources (but they both need their own shaders as OpenGL glsl is a little different from Vulkan glsl).</p>

<p>Both versions look almost identical on my hardware:</p>

<p>Vulkan:</p>

<p><img src="/assets/img/posts/trialspharaoh/comparisonv1-1.webp" style="width:48%" />
<img src="/assets/img/posts/trialspharaoh/comparisonv2.webp" style="width:48%" /></p>

<p>OpenGL:</p>

<p><img src="/assets/img/posts/trialspharaoh/comparisono1-1.webp" style="width:48%" />
<img src="/assets/img/posts/trialspharaoh/comparisono2.webp" style="width:48%" /></p>

<p>The major difference can be seem in the text, it looks sharper and blockier to me in OpenGL, 
I expect this is down to the difference in how each rendering pipeline is set up. 
My Vulkan library draws it’s rendered image to a quad which is then scaled to fit the screen backbuffer. 
The OpenGL implimentation just directly draws on the screen buffer, modifying the draws to account for the backbuffer size.</p>

  </div><a class="u-url" href="/gamejam/2022/05/30/TrialsOfThePharaoh.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">

</footer>
</body>

</html>
